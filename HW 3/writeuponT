The wavefront planner starts at a given node (xStart) within val, determines which of its neighbors has a lower value (distance to goal), and then moves in that direction. Note that, because the wavefront propagator was implemented to always compute the shortest path, any time the planner finds a direction with a value lower than its current position it has found (one of) the shortest paths. As such we only need to check new directions until we find a lower value than the present value, and then move in that direction.

To test our wavefront code, we create the function wavefront_planner_te
st. This code utilizes all our previous wavefront code and only requires a scaler GridSize as an input. It then loads the sphereworld dataset and plots it. We then make and initialize the wavefront array val and propagate all of its values. We call the provided funciton to label the distances on the plot and then run the planner for each of the 5 staring locations in xStart.

Compared to the potential planner, there aren't nearly as many parameters to tune. In this case, we only have the the gridsize to play with. In general, making the grid too coarse will give us inaccurate representations of our obstacles (seen in the case where N = 4) and could lead to collisions or a lack of a path when in fact one is actually present. Making the grid too fine will result in excessive computation and take a significant amount of time. Also, because of the finer granulatiry, the paths can become quite jagged and potentially impracticle to implement. We see this in the case where gridsize = 40, especially around the obstacle at the 3 o'clock position. The paths are jagged and take the "one over, one down" approach. This is not ideal and not smooth, and in practice would require a robot to make many hard turns. Of course there are ways around this, for example we could prioritize always checking the direction we're currently moving in first, and only once that has been disqualified begin checking the other directions. With a smart planner, or with one assisted by the below suggestion, the major drawback to fine grids is simply their increased and unnecessary processing time, while coarse grids misrepresent our workspace and can lead to paths that don't accurately relate back to the physical world, which could cause collisions or impractical paths.

One potential way to speed up the processing for the planner is to store the position of the node that got us there during the propagation function, in, say, a field called origin. In this way we don't need to make any checks for out of bounds or to check the values in the neighboring nodes. This would increase the amount of storage required (though not significantly) but would effectively do the planner's job for it, as it would only need to construct a chain of nodes by querying the current node's origin value.